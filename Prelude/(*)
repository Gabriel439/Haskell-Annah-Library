let shiftL (places : #Bin ) (bin : #Bin ) : #Bin = bin
    #Bin
    #Bin/Zero
    (\(bin_ : #Bin/Bin_ ) ->
        #Bin/One
        (   bin_
            #Bin/Bin_
            (#foldNat places #Bin/Bin_ #Bin/Zero_ #Bin/Nil_ )
            #Bin/Zero_
            #Bin/One_
        )
    )
in

let (*) (bin1 : #Bin ) (bin2 : #Bin ) : #Bin = bin1
    #Bin
    #Bin/Zero
    (\(bin_ : #Bin/Bin_ ) ->
        let x : {1, #Bin , #Bin } = bin_
            {1, #Bin , #Bin }
            <1, #Bin/Zero : #Bin , #Bin/Zero : #Bin >
            (\(t : {1, #Bin , #Bin }) -> t
                {1, #Bin , #Bin }
                (\(place : #Bin ) -> \(accum : #Bin ) ->
                    <1, #Bin/Succ place : #Bin , accum : #Bin >
                )
            )
            (\(t : {1, #Bin , #Bin }) -> t
                {1, #Bin , #Bin }
                (\(place : #Bin ) -> \(accum : #Bin ) ->
                    <1
                    , #Bin/Succ place : #Bin
                    , #(+) (shiftL place bin2) accum : #Bin
                    >
                )
            )
        in  x
            #Bin
            (\(place : #Bin ) -> \(accum : #Bin ) ->
                #(+) (shiftL place bin2) accum
            )
    )

in (*)
