let shiftL (places : #Bin ) (bin : #Bin ) : #Bin = bin
    #Bin
    #Bin/Zero
    (\(bin_ : #Bin/Bin_ ) ->
        #Bin/One
        (   bin_
            #Bin/Bin_
            (#Bin/foldNat places #Bin/Bin_ #Bin/Zero_ #Bin/Nil_ )
            #Bin/Zero_
            #Bin/One_
        )
    )
in

type S
data MkS #Bin #Bin
fold foldS
in

let (*) (bin1 : #Bin ) (bin2 : #Bin ) : #Bin = bin1
    #Bin
    #Bin/Zero
    (\(bin_ : #Bin/Bin_ ) ->
        let x : S = bin_
            S
            (MkS #Bin/Zero #Bin/Zero )
            (\(t : S) -> foldS t
                S
                (\(place : #Bin ) -> \(accum : #Bin ) ->
                    (MkS (#Bin/succ place) accum)
                )
            )
            (\(t : S) -> foldS t
                S
                (\(place : #Bin ) -> \(accum : #Bin ) ->
                    (MkS (#Bin/succ place) (#Bin/(+) (shiftL place bin2) accum))
                )
            )
        in  foldS x
            #Bin
            (\(place : #Bin ) -> \(accum : #Bin ) ->
                #Bin/(+) (shiftL place bin2) accum
            )
    )

in (*)
